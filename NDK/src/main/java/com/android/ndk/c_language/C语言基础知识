1.编译 & 执行 C 程序的步骤：
1）打开一个文本编辑器，编写代码。
2）保存文件为 hello.c。
3）打开命令提示符，进入到保存文件所在的目录。
4）键入 gcc hello.c，输入回车，编译代码（默认会生成a.out的执行文件，-o【文件名称】 可以指定输出文件名称）。
5）键入 a.out 来执行程序。

2.数据类型
1）基本类型：
   整数类型（char、unsigned char、short、unsigned short、int、unsigned int、long、unsigned long、long int、long long）
   浮点类型（float、unsigned float、double、unsigned double、long double）
2）枚举类型
3）void类型：指定没有可用的值，用于三种情况。函数没有返回空、函数参数为空、指针指向空。
4）派生类型：包括指针类型、结构体类型、共用体类型和函数类型

3.变量
1）程序可以操作的存储空间的名称就是变量。变量类型决定了存储空间的大小和布局。
2）变量名称可以由字母、数字和下划线字符组成，它必须以字母或下划线开头。
3）变量的声明有两种情况：
   * 一种是需要建立存储空间的。例如：int a 在声明的时候就已经建立了存储空间。
   * 一种是不需要建立存储空间的，通过使用extern关键字声明变量名而不定义它。例如：extern int a 其中变量 a 可以在别的文件中定义的。

4.常量
1）整数常量：
   * 可以是十进制、八进制或十六进制的常量。0x 或 0X 表示十六进制，0 表示八进制，不带前缀则默认表示十进制。
   * 整数常量也可以带一个后缀，后缀是 U 和 L 的组合，U 表示无符号整数（unsigned），L 表示长整数（long）。后缀可以是大写，也可以是小写，U 和 L 的顺序任意。
2）浮点数常量：数组元素可以通过数组名称加索引进行访问。
   * 浮点常量由整数部分、小数点、小数部分和指数部分组成。
   * 当使用小数形式表示时，必须包含整数部分、小数部分，或同时包含两者。
   * 当使用指数形式表示时，必须包含小数点、指数，或同时包含两者。带符号的指数是用 e 或 E 引入的。例如：6.1E2= 610，61E2=6100。
3）字符常量：字符常量可以是一个普通的字符（例如 'x'）、一个转义序列（例如 '\t'），或一个通用的字符（例如 '\u02C0'）。
4）字符串常量：字符串字面值或常量是括在双引号 " " 中的。
5）定义常量
   在 C 中，有两种简单的定义常量的方式：
   * 使用 #define 预处理器。
   * 使用 const 关键字。

5.存储类
1）auto：所有局部变量默认的存储类，auto 只能用在函数内，即 auto 只能修饰局部变量。
2）static
   * 当 static 修饰局部变量时，可以在函数调用之间保持局部变量的值。
   * 当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。
   * TODO 注意，静态变量在程序中只被初始化一次，即使函数被调用多次，该变量的值也不会重置。
3）extern
   * 当使用 extern 关键字时，不会为变量分配任何存储空间，而只是指示编译器该变量在其他文件中定义。
   * extern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候。
4）register：
   * 定义存储在寄存器中而不是 RAM 中的局部变量。
   * 变量的最大尺寸等于寄存器的大小（通常是一个字），且不能对它应用一元的 '&' 运算符（因为它没有内存位置）。
   * 在需要频繁访问的变量上使用 register 存储类可以提高程序的运行速度。
   * TODO 注意，定义 'register' 并不意味着变量将被存储在寄存器中，它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制。

6.运算符
1）算术运算符：+、-、*、/、%、++、--
2）关系运算符：==、!=、>、<、>=、<=
3）逻辑运算符：&&、||、！
4）位运算符：&（同真为真）、|（有真为真）、^（同假异真）、~（每一位取反）、>>（右移，正数左补0，负数左补1，右边丢弃）、<<（左移，右补0）
5）赋值运算符：=、+=、-=、*=、/=、%=、<<=、>>=、|=、&=、^=
6）杂项运算符：sizeof()（返回变量的大小）、&（返回变量的地址）、*（返回指针变量指向的值）、?:（条件表达式）

7.判断：C语言把任何非零和非空的值假定为 true，把零或 null 假定为 false。
1） if
2） if...else...
3） switch
8.循环
1） 循环类型：while 循环、for 循环、do...while 循环、嵌套循环
2） 循环控制语句：break 语句、continue 语句、goto 语句

9.函数
1） 定义函数：返回类型、函数名称、参数、函数主题
  return_type function_name( parameter list )
  {
     body of the function
  }
2） 函数声明：告诉编译器函数名称及如何调用函数，函数的实际主体可以单独定义。
  return_type function_name( parameter list );
3） 调用函数：调用函数时，传递所需参数，如果函数返回一个值，则可以存储返回值。
4） 函数参数：传值调用（修改函数内的形式参数不会影响实际参数）、引用调用（通过指针传递方式，形参为指向实参地址的指针）。

10.作用域规则
1）作用域是程序中定义的变量所存在的区域，超过该区域变量就不能被访问。
2）局部变量：在某个函数或块的内部声明的变量称为局部变量。存放在栈区，动态地为分配存储单元。
3）全局变量：定义在函数外部，通常是在程序的顶部，整个程序中都是可用的。存放在堆区，占用静态的存储单元。
4）形式参数：函数的参数，被当作该函数内的局部变量，如果与全局变量同名它们会优先使用。
5）初始化局部变量和全局变量：当局部变量被定义时，系统不会对其初始化，必须自行对其初始化。定义全局变量时，系统会自动对其初始化。

11.数组
1）声明数组：type arrayName [ arraySize ];//这叫做一维数组，
   * arraySize 必须是一个大于零的整数常量
   * type 可以是任意有效的 C 数据类型

2）初始化数组：在 C 中，可以逐个初始化数组，也可以使用一个初始化语句。例如：double balance[5] = {1000.0, 2.0, 3.4, 7.0, 50.0};
3）访问数组元素：数组元素可以通过数组名称加索引进行访问。

12.enum枚举
1）枚举是 C 语言中的一种基本数据类型，用于定义一组具有离散值的常量。
2）枚举语法定义格式为：enum　枚举名　{枚举元素1,枚举元素2,……};
3）枚举变量的定义：
  * 先定义枚举类型，再定义枚举变量
  enum DAY
  {
        MON=1, TUE, WED, THU, FRI, SAT, SUN
  };
  enum DAY day;
  * 定义枚举类型的同时定义枚举变量
  enum DAY
  {
        MON=1, TUE, WED, THU, FRI, SAT, SUN
  } day;
  * 省略枚举名称，直接定义枚举变量
  enum
  {
        MON=1, TUE, WED, THU, FRI, SAT, SUN
  } day;

13.指针
1）指针也就是内存地址，指针变量是用来存放内存地址的变量。
2）通过使用一元运算符 * 来返回位于操作数所指定地址的变量的值。
3）声明指针变量是，没有确切的值可以赋值，可以赋为 NULL 值，这种指针被称为空指针。

14.函数指针和回调函数
1）函数指针是指向函数的指针变量。函数指针可以像一般函数一样，用于调用函数、传递参数。
2）函数指针变量的声明：
   typedef int (*fun_ptr)(int,int); // 声明一个指向同样参数、返回值的函数指针类型
3）函数指针变量可以作为某个函数的参数来使用的，回调函数就是一个通过函数指针调用的函数。

15.字符串
1）在 C 语言中，字符串实际上是使用空字符 \0 结尾的一维字符数组。
2）空字符（Null character）又称结束符，缩写 NUL，是一个数值为 0 的控制字符，\0 是转义字符，意思是告诉编译器，这不是字符 0，而是空字符。
3）字符串操作函数：
   * strcpy(s1, s2); 复制字符串 s2 到字符串 s1。
   * strcat(s1, s2); 连接字符串 s2 到字符串 s1 的末尾。
   * strlen(s1); 返回字符串 s1 的长度。这里没有计算结束符号。
   * strcmp(s1, s2); 如果 s1 和 s2 是相同的，则返回 0；如果 s1<s2 则返回小于 0；如果 s1>s2 则返回大于 0。
   * strchr(s1, ch); 返回一个int值，表示字符串 s1 中字符 ch 的第一次出现的位置。
   * strstr(s1, s2); 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。

16.结构体
1）数组可以存储类型相同的变量，结构体允许存储自定义类型不同的变量（相当于 Bean 类）。
2）结构体中的数据成员可以是基本数据类型（如 int、float、char 等），也可以是其他结构体类型、指针类型等。
3）定义结构体：
    struct tag {
      member-list
      member-list
      member-list
      ...
    } variable-list ;
4）结构体变量的初始化：
   * 可以在定义时初始化
   * 在函数中初始化
5）结构体作为函数参数：可以把结构作为函数参数，传参方式与其他类型的变量或指针类似。
6）指向结构的指针：可以定义指向结构的指针，方式与定义指向其他类型变量的指针相似，如下所示：
   struct Books *struct_pointer;
7）结构体占用的内存控件规则：
   * 总的内存必须是最大成员所占内存的整数倍
   * 成员的内存起始位置必须是对应类型的整数倍

17.共用体
1）允许在同一个内存空间存储不同类型的值。
2）可以定义一个带有多成员的共用体，但是任何时候只能有一个成员带有值。
3）定义共用体：
    union [union tag]
    {
       member definition;
       member definition;
       ...
       member definition;
    } [one or more union variables];
4）访问共用体成员：使用共用体变量名+. 可以访问共用体的成员
5）共用体占用内存 == 最大成员的内存

18.位域
1）为了节省结构体的内存，如果结构体内只包含多个TRUE/FALSE 变量，可以使用位域。
2）位域声明：所谓"位域"是把一个字节中的二进位划分为几个不同的区域，并说明每个区域的位数。
struct 位域结构名
{
 type [member_name] : width ;//位域列表
};
3）todo 注意，如果定义的成员需要的位数超过了当前存储单元，会开辟新的存储单元来存放这个成员

19.typedef
1）可以使用它来为类型取一个新的名字。例如：typedef unsigned char BYTE;这里为无符号的字符类型取了一个BYTE的名字。
2）按照惯例，定义时会大写字母，以便提醒用户类型名称是一个象征性的缩写，但您也可以使用小写字母。
3）可以为自定义类型取名字，例如结构体：
typedef struct Books
{
   char  title[50];
   char  author[50];
   char  subject[100];
   int   book_id;
} Book;
4）typedef vs #define：
   * typedef 仅限于为类型定义符号名称，#define 不仅可以为类型定义别名，也能为数值定义别名，比如可以定义 1 为 ONE。
   * typedef 是由编译器执行解释的，#define 语句是由预编译器进行处理的。
   * #define 可以使用其他类型说明符（unsigned）对宏类型名进行扩展，但对 typedef 所定义的类型名却不能这样做。

20.输入&输出
1）getchar() & putchar() 函数，单个字符的输入和输出。
2）gets() & puts() 函数，一行字符的输入和输出，Linux不支持该方法。
3）scanf() 和 printf() 函数，根据format格式带获取输入和打印输出，通过空格来分割输入和输出。

21.文件读写
1）打开文件，下面是这个函数调用的原型：
FILE *fopen( const char *filename, const char *mode );
   * filename 是字符串，用来命名文件，访问模式 mode 的值可以是下列值中的一个：
     r   打开一个已有的文本文件，允许读取文件。
     w   打开一个文本文件，允许写入文件。如果文件不存在，则会创建一个新文件。程序会从文件的开头写入内容。
     a   打开一个文本文件，以追加模式写入文件。如果文件不存在，则会创建一个新文件。
     r+  打开一个文本文件，允许读写文件。
     w+  打开一个文本文件，允许读写文件。如果文件不存在，则会创建一个新文件。如果文件已存在，则文件会被截断为零长度。
     a+  打开一个文本文件，允许读写文件。如果文件不存在，则会创建一个新文件。读取会从文件的开头开始，写入则只能是追加模式。
     如果处理的是二进制文件，则需使用下面的访问模式来取代上面的访问模式：
     "rb", "wb", "ab", "rb+", "wb+", "ab+", "a+b"
    * FILE 返回类型 FILE 包含了所有用来控制流的必要的信息。
2）关闭文件，函数的原型如下：
int fclose( FILE *fp );
   * 如果成功关闭文件，fclose( ) 函数返回零，如果关闭文件时发生错误，函数返回 EOF。
   * 函数会清空缓冲区中的数据，关闭文件，并释放用于该文件的所有内存。
   * EOF 是一个定义在头文件 stdio.h 中的常量。
3）写入文件
   * int fputc( int c, FILE *fp ); //把参数 c 的字符值写入到 fp 所指向的输出流中。
   * int fputs( const char *s, FILE *fp ); //把一个以 null 结尾的字符串写入到流中。
   * int fprintf(FILE *fp, const char *format, ...); //把一个字符串按照format格式写入到文件中。
4）读取文件
   * int fgetc( FILE * fp ); //从 fp 所指向的输入文件中读取一个字符。返回值是读取的字符，如果发生错误则返回 EOF。
   * char *fgets( char *buf, int n, FILE *fp ); //从 fp 中读取 n - 1 个字符。遇到换行或 EOF，会停止读取。
   * int fscanf(FILE *fp, const char *format, ...); //从 fp 中读取字符串，遇到第一个空格和换行符时，会停止读取。
5）二进制 I/O 函数
   * size_t fread(void *ptr, size_t size_of_elements, size_t number_of_elements, FILE *a_file);
   * size_t fwrite(const void *ptr, size_t size_of_elements, size_t number_of_elements, FILE *a_file);

22.预处理器
1）预处理器只不过是一个文本替换工具而已，它们会指示编译器在实际编译之前完成所需的预处理。我们将把 C 预处理器（C Preprocessor）简写为 CPP。
2）所有的预处理器命令都是以井号（#）开头。它必须是第一个非空字符，为了增强可读性，预处理器指令应从第一列开始。
3）重要的预处理器指令：
   * #define    定义宏
   * #include   包含一个源代码文件
   * #undef     取消已定义的宏
   * #ifdef	    如果宏已经定义，则返回真
   * #ifndef	如果宏没有定义，则返回真
   * #if	    如果给定条件为真，则编译下面代码
   * #else	    #if 的替代方案
   * #elif	    如果前面的 #if 给定条件不为真，当前条件为真，则编译下面代码
   * #endif	    结束一个 #if……#else 条件编译块
   * #error	    当遇到标准错误时，输出错误消息
   * #pragma	使用标准化方法，向编译器发布特殊的命令到编译器中
4）预定义宏：ANSI C 定义了许多宏。在编程中您可以使用这些宏，但是不能直接修改这些预定义的宏。
5）预处理器运算符：“\”，拼接运算符。

23.头文件
1）头文件是扩展名为 .h 的文件，包含了 C 函数声明和宏定义，被多个源文件中引用共享。
2）有两种类型的头文件：程序员编写的头文件和编译器自带的头文件。
   * 编译器自带的头文件引用方式：#include <file>
   * 程序员编写的头文件饮用方式：#include "file"
3）引用头文件的操作：预处理器会把#include引用文件替换到当前文件并一起输出
4）只引用一次头文件：为了避免多次引用导致错误，可以使用包装器 #ifndef。来保证只引用一次头文件
#ifndef HEADER_FILE
#define HEADER_FILE

the entire header file file

#endif
5）有条件引用：有时需要从多个不同的头文件中选择一个引用到程序中
#if SYSTEM_1
   # include "system_1.h"
#elif SYSTEM_2
   # include "system_2.h"
#elif SYSTEM_3
   ...
#endif
但是如果头文件比较多，可以使用宏定义头文件名称：
#define SYSTEM_H "system_1.h"
 ...
#include SYSTEM_H

24.强制类型转换
1）格式：(type_name) expression
2）整数提升：整数提升是指把小于 int 或 unsigned int 的整数类型转换为 int 或 unsigned int 的过程。
3）常用的算术转换：是隐式地把值强制转换为相同的类型。
int->unsigned int->long->unsigned long->unsigned long long->float->double->long double
例如：float sum = 1 + 'c'；这里先把'c'整数提升为int 类型，再把1和c转为浮点类型，然后相加得到一个浮点数。
4）todo 注意，常用的算术转换不适用于赋值运算符、逻辑运算符 && 和 ||。

25.错误处理
1）C 语言不提供对错误处理的直接支持，但是作为一种系统编程语言，它以返回值的形式允许您访问底层数据。
2）在发生错误时，大多数的 C 或 UNIX 函数调用返回 1 或 NULL，同时会设置一个错误代码 errno。可以在 errno.h 头文件中找到各种各样的错误代码。
3）开发人员应该在程序初始化时，把 errno 设置为 0，这是一种良好的编程习惯。0 值表示程序中没有错误。
4）打印错误码对应的错误信息：
   * perror() 函数显示传给它的字符串，后跟一个冒号、一个空格和当前 errno 值的文本表示形式。
   * strerror() 函数，返回一个指针，指针指向当前 errno 值的文本表示形式。

26.递归
1）一个函数可以调用其自身，但在使用递归时，需要注意定义一个从函数退出的条件，否则会进入死循环。
2）数的阶乘：n*(n-1)...*1
3）斐波那契数列：n+(n+1)= (n+2)

27.可变参数
1)声明方式为：int func_name(int arg1, ...);
   * arg1，表示要传递的参数个数
   * ...，表示可变参数列表
2）使用可变参数：
   * 定义一个函数，最后一个参数为省略号，省略号前面可以设置自定义参数。
   * 在函数定义中创建一个 va_list 类型变量接收可变参数，该类型是在 stdarg.h 头文件中定义的。
   * 使用 int 参数和 va_start(va_list, int) 宏来初始化 va_list 变量为一个参数列表。
   * 使用 va_arg(va_list, type) 宏和 va_list 变量来访问参数列表中的每个项。type是下一个参数的类型。
   * 使用宏 va_end(va_list) 来清理赋予 va_list 变量的内存。

28.内存管理
1）C 语言为内存的分配和管理提供了几个函数。这些函数可以在 <stdlib.h> 头文件中找到。
2）动态分配内存：void *malloc(int num);
   * 在堆区分配一块指定大小的内存空间，用来存放数据。这块内存空间在函数执行完成后不会被初始化，它们的值是未知的。
3）重新调整内存的大小和释放内存：void *realloc(void *address, int newsize);

29.命令行参数
1）在程序允许过程中，想通过命令行传递参数控制程序执行。
2）命令行参数是使用 main(int argc, char *argv[]) 函数参数来处理的，其中，argc 是指传入参数的个数，argv[] 是一个指针数组，指向传递给程序的每个参数。
   * argv[0] 存储程序的名称，如果没有提供任何参数，argc 长度就是1。
   * argv[1] 是一个指向第一个命令行参数的指针，argv[n]是第n个命令行参数。
   * 参数之间用空格分割，如果一个参数内部包含空格，就需要用双引号 "" 或单引号 '' 括起来。

30.排序算法
1）冒泡排序：重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序（如从大到小、首字母从A到Z）错误就把他们交换过来。
void bubble_sort(int arr[], int len) {
    int i, j, temp;
    for (i = 0; i < len - 1; i++)           //遍历每一个元素
        for (j = 0; j < len - 1 - i; j++)   //两两比较次数
            if (arr[j] > arr[j + 1]) {      //比较第j个元素和第j+1个元素
                temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
}
2）选择排序：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，
然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。
void selection_sort(int a[], int len)
{
    int i,j,temp;

    for (i = 0 ; i < len - 1 ; i++)
    {
        int min = i;                       // 记录最小值，第一个元素默认最小
        for (j = i + 1; j < len; j++)     // 访问未排序的元素
        {
            if (a[j] < a[min])           // 找到目前最小值
            {
                min = j;                 // 记录最小值
            }
        }
        if(min != i)
        {
            temp = a[min];                // 交换两个变量
            a[min] = a[i];
            a[i] = temp;
        }
    }
}
3）插入排序：通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。
void insertion_sort(int arr[], int len){
    int i, j, temp;
    for (i = 1; i < len; i++){
            temp = arr[i];
            for (j = i; j > 0 && arr[j-1] > temp; j--)
                    arr[j] = arr[j-1];
            arr[j] = temp;
    }
}



